import numpy as np

a = np.arange(12).reshape(3, 4)
print(a)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

i = np.array([[0, 1], [1, 2]])

j = np.array([[2, 1], [3, 3]])

print(a[i, j])
# [[ 2  5]
#  [ 7 11]]

# 解释：
# a[i, j] 通过组合两个索引数组 i 和 j，从 a 中选择元素：
# i 代表行索引，j 代表列索引。
# 第一个位置：
# i[0, 0] = 0（选择第 0 行）
# j[0, 0] = 2（选择第 2 列）
# 所以选择 a[0, 2] → 2
# 第二个位置：
# i[0, 1] = 1（选择第 1 行）
# j[0, 1] = 1（选择第 1 列）
# 所以选择 a[1, 1] → 5
# 第三个位置：
# i[1, 0] = 1（选择第 1 行）
# j[1, 0] = 3（选择第 3 列）
# 所以选择 a[1, 3] → 6
# 第四个位置：
# i[1, 1] = 2（选择第 2 行）
# j[1, 1] = 3（选择第 3 列）
# 所以选择 a[2, 3] → 11

print(a[i, 2])
# [[ 2  6]
#  [ 6 10]]

# 解释
# a[0, 2] = 2
# a[1, 2] = 6
# a[1, 2] = 6
# a[2, 2] = 10

print(a[:, j])
# a[:, j] 中的 : 选择所有行，而 j 指定了列索引
# [0, 1]  [[2, 1], [3, 3]]

# [[[ 2  1]
#   [ 3  3]]
#
#  [[ 6  5]
#   [ 7  7]]
#
#  [[10  9]
#   [11 11]]]

'''
索引规则：
: 表示在第一个维度（也就是行维度）上选取所有行，而 j 作为索引数组用于指定列索引。
这意味着对于 a 数组的每一行，都要按照 j 中对应位置的列索引去获取元素，最终形成一个三维数组结构。

详细过程及结果：

对于 j 的第一行 [2, 1]，从 a 的每一行（共 3 行）中分别选取列索引为 2 和 1 的元素。
第一行选取到 (0, 2) 位置的元素 2 和 (0, 1) 位置的元素 1，组成子数组 [2, 1]；
第二行选取到 (1, 2) 位置的元素 6 和 (1, 1) 位置的元素 5，组成子数组 [6, 5]；
第三行选取到 (2, 2) 位置的元素 10 和 (2, 1) 位置的元素 9，组成子数组 [10, 9]。
这些子数组按行排列形成一个形状为 (3, 2) 的二维数组，这是结果中的一部分。

对于 j 的第二行 [3, 3]，同样从 a 的每一行中选取列索引为 3 的元素。
第一行选取到 (0, 3) 位置的元素 3 两次（因为 j 的第二行两个元素都是 3），组成子数组 [3, 3]；
第二行选取到 (1, 3) 位置的元素 7 两次，组成子数组 [7, 7]；
第三行选取到 (2, 3) 位置的元素 11 两次，组成子数组 [11, 11]。这些子数组按行排列又形成一个形状为 (3, 2) 的二维数组，这是结果中的另一部分。

最后将这两个 (3, 2) 的二维数组沿着第三个维度（可以理解为深度维度，在 Python 中体现为外层再嵌套一层列表结构）进行组合，就形成了最终的三维数组结果：
'''

l = (i, j) # 相当于 a[i, j]
print(a[l])
