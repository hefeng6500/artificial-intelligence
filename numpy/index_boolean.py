'''
布尔索引：a[b] 使用布尔数组 b 从 a 中选择元素，返回的是一个一维数组，只包含那些对应位置为 True 的元素。
这是因为 布尔索引是一个“扁平化”操作，它忽略了原数组的形状，只返回符合条件的元素。
'''
import numpy as np

a = np.arange(12).reshape(3, 4)
b = a > 4
print(b)  # `b` is a boolean with `a`'s shape
print(a[b])  # 1d array with the selected elements

# a[b] = 0 # All elements of `a` higher than 4 become 0

print(a)

b1 = np.array([False, True, True])  # first dim selection
b2 = np.array([True, False, True, False])  # second dim selection

print(a[b1, :])

# [[ 4  5  6  7]
#  [ 8  9 10 11]]

# b1 是一个长度为 3 的布尔数组，代表选择行：
# b1[0] = False → 不选择第一行（[0, 1, 2, 3]）
# b1[1] = True → 选择第二行（[4, 5, 6, 7]）
# b1[2] = True → 选择第三行（[8, 9, 10, 11]）

print(a[b1, :])  # same as a[b1]
# [[ 0  2]
#  [ 4  6]
#  [ 8 10]]
# b2 是一个长度为 4 的布尔数组，代表选择列：
# b2[0] = True → 选择第一列（[0, 4, 8]）
# b2[1] = False → 不选择第二列（[1, 5, 9]）
# b2[2] = True → 选择第三列（[2, 6, 10]）

# a[b1, b2]：奇怪的操作
print(a[b1, b2])
# [ 4 10]
   
# 这是一个不常见的操作，使用了两个布尔数组进行索引：
#
# b1 用来选择 行。
# b2 用来选择 列。
# 如何理解：
#
# b1 的长度是 3，表示选择行。b2 的长度是 4，表示选择列。
# 在 a[b1, b2] 中，两个布尔数组 b1 和 b2 被同时应用到 a 中，但这并不是常见的二维数组切片方式。
# 具体的选取方式：
#
# b1[0] = False → 不选择第一行
# b1[1] = True → 选择第二行
# b1[2] = True → 选择第三行
# 对应到列的选择：
#
# b2[0] = True → 选择第一列
# b2[1] = False → 不选择第二列
# b2[2] = True → 选择第三列
# b2[3] = False → 不选择第四列
# 选择过程：
#
# 第一行 b1[0] 为 False，所以不选择第一行。
# 第二行 b1[1] 为 True，所以选择第二行（[4, 5, 6, 7]）。
# 第三行 b1[2] 为 True，所以选择第三行（[8, 9, 10, 11]）。
# 然后根据 b2 的值进行列选择：
#
# 第一列（b2[0] = True）→ 从第二行和第三行中取出第一列的元素，分别为 4 和 8。
# 第三列（b2[2] = True）→ 从第二行和第三行中取出第三列的元素，分别为 6 和 10。
# 结合行和列索引的选择结果后，最终得到的是 4 和 10。
#
# 这些元素按顺序排列，形成了一个 一维数组 [4, 10]。